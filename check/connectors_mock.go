// Automatically generated by MockGen. DO NOT EDIT!
// Source: connectors.go

package check

import (
	gomock "github.com/golang/mock/gomock"
	kafka "github.com/optiopay/kafka"
	proto "github.com/optiopay/kafka/proto"
	zk "github.com/samuel/go-zookeeper/zk"
	time "time"
)

// Mock of BrokerConnection interface
type MockBrokerConnection struct {
	ctrl     *gomock.Controller
	recorder *_MockBrokerConnectionRecorder
}

// Recorder for MockBrokerConnection (not exported)
type _MockBrokerConnectionRecorder struct {
	mock *MockBrokerConnection
}

func NewMockBrokerConnection(ctrl *gomock.Controller) *MockBrokerConnection {
	mock := &MockBrokerConnection{ctrl: ctrl}
	mock.recorder = &_MockBrokerConnectionRecorder{mock}
	return mock
}

func (_m *MockBrokerConnection) EXPECT() *_MockBrokerConnectionRecorder {
	return _m.recorder
}

func (_m *MockBrokerConnection) Dial(nodeAddresses []string, conf kafka.BrokerConf) error {
	ret := _m.ctrl.Call(_m, "Dial", nodeAddresses, conf)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockBrokerConnectionRecorder) Dial(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Dial", arg0, arg1)
}

func (_m *MockBrokerConnection) Consumer(conf kafka.ConsumerConf) (kafka.Consumer, error) {
	ret := _m.ctrl.Call(_m, "Consumer", conf)
	ret0, _ := ret[0].(kafka.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockBrokerConnectionRecorder) Consumer(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Consumer", arg0)
}

func (_m *MockBrokerConnection) Producer(conf kafka.ProducerConf) kafka.Producer {
	ret := _m.ctrl.Call(_m, "Producer", conf)
	ret0, _ := ret[0].(kafka.Producer)
	return ret0
}

func (_mr *_MockBrokerConnectionRecorder) Producer(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Producer", arg0)
}

func (_m *MockBrokerConnection) Metadata() (*proto.MetadataResp, error) {
	ret := _m.ctrl.Call(_m, "Metadata")
	ret0, _ := ret[0].(*proto.MetadataResp)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockBrokerConnectionRecorder) Metadata() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Metadata")
}

func (_m *MockBrokerConnection) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockBrokerConnectionRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

// Mock of ZkConnection interface
type MockZkConnection struct {
	ctrl     *gomock.Controller
	recorder *_MockZkConnectionRecorder
}

// Recorder for MockZkConnection (not exported)
type _MockZkConnectionRecorder struct {
	mock *MockZkConnection
}

func NewMockZkConnection(ctrl *gomock.Controller) *MockZkConnection {
	mock := &MockZkConnection{ctrl: ctrl}
	mock.recorder = &_MockZkConnectionRecorder{mock}
	return mock
}

func (_m *MockZkConnection) EXPECT() *_MockZkConnectionRecorder {
	return _m.recorder
}

func (_m *MockZkConnection) Connect(servers []string, sessionTimeout time.Duration) (<-chan zk.Event, error) {
	ret := _m.ctrl.Call(_m, "Connect", servers, sessionTimeout)
	ret0, _ := ret[0].(<-chan zk.Event)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockZkConnectionRecorder) Connect(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Connect", arg0, arg1)
}

func (_m *MockZkConnection) Close() {
	_m.ctrl.Call(_m, "Close")
}

func (_mr *_MockZkConnectionRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockZkConnection) Exists(path string) (bool, *zk.Stat, error) {
	ret := _m.ctrl.Call(_m, "Exists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(*zk.Stat)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockZkConnectionRecorder) Exists(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Exists", arg0)
}

func (_m *MockZkConnection) Set(path string, data []byte, version int32) (*zk.Stat, error) {
	ret := _m.ctrl.Call(_m, "Set", path, data, version)
	ret0, _ := ret[0].(*zk.Stat)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockZkConnectionRecorder) Set(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Set", arg0, arg1, arg2)
}

func (_m *MockZkConnection) Create(path string, data []byte, flags int32, acl []zk.ACL) (string, error) {
	ret := _m.ctrl.Call(_m, "Create", path, data, flags, acl)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockZkConnectionRecorder) Create(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Create", arg0, arg1, arg2, arg3)
}

func (_m *MockZkConnection) Children(path string) ([]string, *zk.Stat, error) {
	ret := _m.ctrl.Call(_m, "Children", path)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(*zk.Stat)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockZkConnectionRecorder) Children(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Children", arg0)
}

func (_m *MockZkConnection) Get(path string) ([]byte, *zk.Stat, error) {
	ret := _m.ctrl.Call(_m, "Get", path)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(*zk.Stat)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

func (_mr *_MockZkConnectionRecorder) Get(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Get", arg0)
}

func (_m *MockZkConnection) NewLock(path string, acl []zk.ACL) (ZkLock, error) {
	ret := _m.ctrl.Call(_m, "NewLock", path, acl)
	ret0, _ := ret[0].(ZkLock)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockZkConnectionRecorder) NewLock(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "NewLock", arg0, arg1)
}

// Mock of ZkLock interface
type MockZkLock struct {
	ctrl     *gomock.Controller
	recorder *_MockZkLockRecorder
}

// Recorder for MockZkLock (not exported)
type _MockZkLockRecorder struct {
	mock *MockZkLock
}

func NewMockZkLock(ctrl *gomock.Controller) *MockZkLock {
	mock := &MockZkLock{ctrl: ctrl}
	mock.recorder = &_MockZkLockRecorder{mock}
	return mock
}

func (_m *MockZkLock) EXPECT() *_MockZkLockRecorder {
	return _m.recorder
}

func (_m *MockZkLock) Unlock() error {
	ret := _m.ctrl.Call(_m, "Unlock")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockZkLockRecorder) Unlock() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Unlock")
}
